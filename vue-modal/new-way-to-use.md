# A new look at modals in vue 3

В данной статье я подниму тему использования модальных окон для
веб-приложений. Я не буду затрагивать `<dialog/>` из HTML.
Речь пойдёт про модальные окна в экосистеме `vue`. Код и нашу
реализацию можно посмотреть здесь
[`jenesius-vue-modal`](https://github.com/Jenesius/vue-modal).

Новая возможность `teleport` в третьей версии `vue` позволяет переместить
содержимое в нужное вам место. И это круто! Наверное. Попытавшись
использовать у себя на проекте, моя команда столкнулась со следующей
проблемой: как поддерживать такой код, когда любая компонента может
вставить что-то в любое место вашего продукта.

Мы добавляли абстракции, новые компоненты, которые использовались только
для ограничения использование `teleport`. 

У нас на проекте изобильно использовались модальные окна. Открыть одно,
открыть другое поверх, вернуть значение из модального окна, интегрировать
модальное окно в `vue-router` - это не полный список того, что мы 
реализовали. 

Сперва мы использовали крутую библиотеку, но вот такой
подход раздражал всю нашу команду:

```xhtml
<!--widget-user-item.vue-->
<div>
    <div>. . .</div>
    <teleport>
        <modal-user :user-id = "id"  v-if = "isActive"/>
    </teleport>
</div>
```

Для нас выглядело это, как что-то несуразное и очень хотелось от этого
избавиться. Мы хотели избавиться от описания компоненты модального
окна в другой компоненте. Нашей задачей стало вынесения модальных 
окон на другой уровень, другой слой.

## Состояние модальной системы

В `vue` очень удобно использовать реактивные состояния на базе `ref`/`reactive`.
Добавляем очередь, которая в себе будет хранить открытые модальные окна:

```ts
const modalQueue = reactive([]);
```

При добавлении модального окна мы будем туда записывать значение, при удалении
- удалять. Всё как-бы очень просто. Теперь что-бы открыть модальное окно
добавим метод `openModal`:

```javascript
function openModal(component, props) {
    modalQueue.push({component, props});
}
```

Для закрытия используем метод `splice`.

Теперь осталось модальные окна отобразить. Создадим для этого отдельную
компоненту в которой будет отображать переданные компоненты. Также
не забудем передать туда `props`:

```html
<!--modal-container.vue-->
<div>
    <component 
        v-for = "item in modalQueue"
        :is = "item.component" 
        v-bind = "item.props"
    />        
</div>

```

Чтобы открыть модальное окно из нашей новой карточки пользователя,
добавим обработчик нажатия и вызов новой функции:

```vue
<template>
    ...
    <button @click = "showUserModal">open</button>
</template>
<script setup>
    const props = defineProps(['userId'])
    
    function showUserModal() {
        openModal(ModalUser, {
            userId: props.modalId
        })
    }
</script>
```

Это лишь краткая, но основная часть того, что мы реализовали. Для нас
такой подход позволяет более точно и безопасно строить интерфейсы.

Со всей кодовой базой можно ознакомиться в публичном репозитории на
[GitHub](https://github.com/Jenesius/vue-modal). Там мы постарались
привести примеры использования данной библиотеки. Также мы описали
инструкцию и сделали приятную документацию.