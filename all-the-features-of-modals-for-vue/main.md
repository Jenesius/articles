Я часто вижу как в дискорд каналах, на `Reddis`, да даже на `Habr`
поднимается тема модальных окон. Если зайти в официальный дискорд канал
`Vue` и включить поиск по слову _modal_, можно обнаружить, что вопросы
задаются каждый день. Хотя что может быть сложного в модальных окнах?
Создал переменную `isShow`, нацепил её на компоненту при помощи `v-if`
и готово. Именно это я вижу в **90%** проектов. Но так ли удобен такой
подход - определённо нет. 

Пару лет назад я решил раз и навсегда разобраться с modals, в этой 
статье будут приведены примеры использования, а также я прикреплю ссылку
на [репозиторий](https://github.com/Jenesius/vue-modal), в котором
можно посмотреть к чему я пришёл.

Побегав поиском по Discord (искал следующие слова: `modal`, `dialog`,
`popup`) я выделил 4 основные темы, которые поднимают разработчики:

- как открыть модальное окно
- как открыть модальное окно поверх предыдущего
- как вернуть значение из модального окна
- как прикрепить модальное окно к определённому `route`

Отлично! У нас есть требования, теперь пора их выполнить. Данная статья
будет разбита на 4 части, каждая посвящена одному из вышеописанных
пунктов. Начнём.

## Как открыть модальное окно

Мне всегда было неудобно вставлять компоненту модального окна напрямую 
в другую компоненту. Выглядит это следующим образом:

```vue
<!-- widget-user-card.vue -->
<template>
    <div class = "user">
        <!--user-card-->
        <button @click = "openUserModal"></button>
        <modal-user :id = "userId" v-if = "isOpen"/>
    </div>
</template>
<script setup>
    const props = defineProps(['userId'])
    const isOpen = ref(false);
	
	function openUserModal() {
		isOpen.value = true;
    }
</script>
```

Если у нас приложение с одним модальным окном - нас это решение устроит.
Но в иных ситуациях это перегружает компоненту. В `vue` третьей версии
было добавлен `teleport`, для рендеринга компоненты в другой части
приложения, но это ещё сильнее захламляет нашу компоненту. В своём
проекте мы добавили новую абстракцию и передавали в неё компоненту,
которая потом `'телепортилась'` в нужное нам место.

Теперь давайте попробуем сделать это более элегантно и удобно. Как
видно из требований, нам иногда нужно отобразить несколько окон. По
этому создадим динамическую очередь, в которой будут храниться активные
модальные окна. Также опишем функцию `openModal`, которая будет использоваться
для открытия этих модальных окон. :

```javascript
const modalQueue = reactive([]);

function openModal(component, props) {
    // We need close all opened modals before add new.
    modalQueue.splice(0, modalQueue.length);
    modalQueue.push({component, props})
}
```
В функцию для открытия модального окна передаётся компонента, которую
необходимо отобразить, и `props` которые будут установлены в ней. Также
не забываем, что нам нужно закрыть все ранее открытые модальные окна.

Функционал реализован, теперь создадим компоненту: контейнер в котором
данная `modalQueue` будет отображаться:

```vue
<!--modal-container.vue-->
<template>
    <component 
        v-for = "item in modalQueue"
        
        :is = "item.component"
        v-bind = "item.props"
    />
</template>
```

Я убрал описание `CSS` классов, затемнение и все остальные вторичные
детали. Здесь мы видим самое важное:
- Отображение всех компонент из modalQueue
- Передача всех `props` через `v-bind`

Также нам необходимо добавить данный контейнер в наше приложение. Я
предпочитаю добавлять его в самый конец `App.vue` компоненты, чтобы
модальные окна были всегда поверх других компонент.

Теперь обновим нашу `widget-user-card` компоненту:

```vue
<!-- widget-user-card.vue -->
<template>
    <div class = "user">
        <!--user-card-->
        <button @click = "openUserModal"></button>
    </div>
</template>
<script setup>
    const props = defineProps(['userId'])
	
    function openUserModal() {
        openModal(ModalUser, { id: props.userId })
    }
</script>
```


Мы избавились от лишней логики в самой компоненте, и код стал более
чистым. Нам необязательно сохранять здесь реактивность, т.к. модальное
окно это новый слой логики. Но нам ничего не мешает передать туда
`computed` переменную.

## Как открыть несколько модальных окон




