Я часто вижу как в `Discrod`, на `Reddis`, да даже на `Habr`
поднимается тема модальных окон. Если зайти в официальный дискорд канал
`Vue` и включить поиск по слову _modal_, можно обнаружить, что вопросы
задаются каждый день. Хотя что может быть сложного в модальных окнах?
Создадим переменную `isOpen`, добавим `v-if` и готово. Именно это я
вижу в **90%** проектов. Но так ли удобен такой подход - определённо нет. 

Пару лет назад я решил раз и навсегда разобраться с modals. В этой 
статье будет рассказано, как разработчики применяют модальные окна, как
элегантно добавить их в свой проект. Все описанные подходы были
собраны в единую библиотеку `jenesius-vue-modal` и описаны на
[GitHub](https://github.com/Jenesius/vue-modal). 

Я поискал в официальном `Discrod` канале сообщения связанные с `modal` и
`dialog` и выделил 4 основные темы, которые поднимают разработчики:

- как открыть модальное окно
- как открыть модальное окно поверх предыдущего
- как вернуть значение из модального окна
- как прикрепить модальное окно к определённому `route`

Отлично! У нас есть требования, теперь пора их выполнить. Данная статья
будет разбита на 4 части, каждая посвящена одному из вышеописанных
пунктов. Начнём.

## Как открыть модальное окно

Мне всегда было неудобно вставлять компоненту модального окна напрямую 
в другую компоненту. Выглядит это следующим образом:

```vue
<!-- widget-user-card.vue -->
<template>
    <div class = "user">
        <!--user-card-->
        <button @click = "openUserModal"></button>
        <!--modal-->
        <modal-user :id = "userId" v-if = "isOpen"/>
    </div>
</template>
<script setup>
    const props = defineProps(['userId'])
    const isOpen = ref(false);
	
    function openUserModal() {
        isOpen.value = true;
    }
</script>
```

Если у нас приложение с одним модальным окном, то такой подход нас устроит.
Но в иных ситуациях это перегружает компоненту из-за чего их объём
начинает расти.

В `vue` третьей версии был добавлен `teleport`, для рендеринга компоненты
в другой части нашего приложения, но это ещё сильнее захламляет наш файл.
В своём проекте мы добавили новую абстракцию и передавали в неё компоненту,
которая потом `'телепортилась'` в нужное нам место.

Теперь давайте попробуем сделать это более элегантно и удобно. Как
видно из требований, нам иногда нужно отобразить несколько окон. По
этому создадим динамическую очередь, в которой будут храниться активные
модальные окна. Также опишем функцию `openModal`, которая будет использоваться
для открытия этих модальных окон:

```javascript
const modalQueue = reactive([]);

function openModal(component, props) {
    // We need close all opened modals before add new.
    modalQueue.splice(0, modalQueue.length);
    modalQueue.push({component, props})
}
```
В функцию для открытия модального окна передаётся компонента, которую
необходимо отобразить, и `props` которые будут установлены в ней. Также
не забываем, что нам нужно закрыть все ранее открытые модальные окна.

Функционал реализован, теперь создадим компоненту: контейнер в котором
данная `modalQueue` будет отображаться:

```vue
<!--modal-container.vue-->
<template>
    <component 
        v-for = "item in modalQueue"
        
        :is = "item.component"
        v-bind = "item.props"
    />
</template>
```

Я убрал описание `CSS` классов, затемнение и все остальные вторичные
детали. Здесь мы видим самое важное:
- Отображение всех компонент из modalQueue
- Передача всех `props` через `v-bind`

Также нам необходимо добавить данный контейнер в наше приложение. Я
предпочитаю добавлять его в самый конец `App.vue` компоненты, чтобы
модальные окна были всегда поверх других компонент.

Теперь обновим наш `widget-user-card` файл:

```vue
<!-- widget-user-card.vue -->
<template>
    <div class = "user">
        <!--user-card-->
        <button @click = "openUserModal"></button>
    </div>
</template>
<script setup>
    const props = defineProps(['userId'])
	
    function openUserModal() {
        openModal(ModalUser, { id: props.userId })
    }
</script>
```

Выглядит это следующим образом:
*****
РИСУНОК 1
*****


Мы избавились от лишней логики в компоненте, а код стал чище.
Нам необязательно сохранять реактивность при передаче `props` в функцию,
т.к. модальное окно это новый слой логики. Но нам ничего не мешает
передать туда `computed` переменную.

## Как открыть несколько модальных окон

Поскольку для хранения модальных окон мы заранее выбрали реактивный 
массив, то для показа нового окна необходимо попросту добавить в конец
новые данные. Добавим функцию `pushModal`, которая будет делать то же
самое, что и `openModal`, но без очистки массива:

```ts
function pushModal(component, props) {
    modalQueue.push({component, props})
}
```

Выглядит это следующим образом:
*****
РИСУНОК 2
*****


Также я могу выделить, ещё один подход: на странице у нас всегда показывается
лишь последнее модальное окно, а остальные скрываются с сохранением
внутреннего состояния. 

## Как вернуть значение из модального окна

Это самые популярный вопрос, который я встречал, т.к. предыдущие
два интуитивно понятны. Если мы говорим о возвращаемом значении
модальных окон, мы должны сначала понять их суть. По умолчанию 
модальные окна рассматриваются как отдельный уровень логики со своей 
собственной моделью данных. Такой подход удобен и делает разработку
веб-приложения с модальными окнами безопасной. Я считаю примерно также.
Модальное окно — это отдельный логический уровень, принимающий входные
параметры и каким-то образом с ними взаимодействующий. Однако бывают
случаи, когда модальное окно является лишь частью процесса. 

Первое, что приходит на ум: передать `callback`, который будет вызван
самим модальным окном в конце процесса.

```javascript
openModal(ModalSelectUser, {
    resolve(userId) {
        // Do something
    }
})
```

Callback-и это круто, но для меня более удобным является линейный код,
используя `Promise`. По этому функцию для возвращения значения я реализовал
следующим образом:

```ts
function promptModal(component, props) {
    return new Promise(resolve => {
        pushModal(component, {
            ...props,
            resolve
        })
    })
}
```

В качестве `callback` мы всегда передаём `resolve` в качестве props и 
вызываем его уже внутри модального окна:

```vue
<!--modal-select-user.vue-->
<template>
    <!-- -->
    <button @click = "handleSelect"></button>
</template>
<script setup>
const props = defineProps(['resolve'])

function handleSelect() {
    props.resolve(someData);
}
</script>
```

Выглядит это следующим образом:
*****
РИСУНОК 2
*****

Максимально упрощенный пример в котором компонента возвращает данные,
отправляя их в `resolve`.  Пример вызова данной функции:
```javascript
const userId = await promptModal(ModalSelectUser)
```

Для меня такой подход выглядит как-то свежее.

## Как прикрепить модальное окно к определённому `route`

И на конец интеграция с `vue-roter`. Основная задача: когда пользователь
переходит на `/user/5`, отобразить модальное окно карточки пользователя.
Первое, что приходит на ум: в компоненте `user-card` в момент onMount
открывать модальное окно, в момент unMount закрывать. Это отлично будет
работать. 

Давайте выделим какие проблемы нас тут могут ждать и что нужно учесть:

- Обновление компоненты в `onBeforeRouteUpdate`. В случае, если у нас
происходит переход с `user/4` на `user/8`, onMount не будет вызван.
- Если модальное окно было закрыто, необходимо вернуться на шаг назад
в vue-router. Вернуться на предыдущий route можно закрытием непосредственно
модального, а можно использовать клавишу _"назад"_ на вашем девайсе. 
Во втором случае необходимо контролировать, чтобы мы не ушли сразу
на два шага назад (нажатие на _"назад"_, закрытие modal).

Это не весь список. К нему можно добавить обработчики закрытия окна.
Например, если мы добавим в модальные окна хуки, которые будут запрещать
закрытие, пока пользователь на примет _"Согласие на обработку данных"_, 
переход на нужные route не должен происходить.

Реализуем базовую функцию-обёртку, которую будем передавать в `Router`, когда
инициализируем наше приложение. И постепенно будем её наполнять:

```javascript

function useModalRouter(component) {
    return {
        setup() {
            // 
            return () => null
        }
    }
}
```

При инициализации `route` будем оборачивать модальные окна этой
функцией:

```javascript
const routes = [
    {
        path: "/users",
        component: WidgetUserList,
        children: [
            {
                path: ":user-id",
                component: useModalRouter(ModalUser) // Here
            }
        ]
    }
]
```

При переходе на `/users/5` мы не будем ничего создавать и устанавливать. 
Именно для этого `setup` функция возвращает null. Теперь нам нужно
отобразить модальное окно.

```js
function useModalRouter(component) {
	return {
        setup() {
            function init() {
                openModal(component)
            }
            onMounte(init)
            onBeforeRouteUpdate(init)
            onBeforeRouteLeave(popModal);
            
            return () => null
        }
    }
}
```

Добавим также метод `popModal` для закрытия последнего открытого модального
окна:

```javascript
function popModal() {
    modalQueue.pop();
}
```


Если попытаться сделать через весь набор хуков `onMount`, `onUnmount`,
`onBeforeRouteUpdate`, мы создадим _Frankenstein's monster_. Также 
в примере выше есть проблема с передачей props. Нужно это как-то решать.
Давайте поменяем наш подход и будем просматривать каждое изменение 
`router`. Да, данный подход может показаться не оптимальным, однако мы
сразу же решим две проблемы:

- интеграция с vue-router
- закрытие модального окна при переходе на другой маршрут.

В конечном итоге мы реализуем что-то похожее на это:
```ts
router.afterEach(async (to) => {
    closeModal(); // [1]
    const modalComponent = findModal(to); // [2]
    if (modal) await modalComponent.initialize(); // [3]
})
```

Давайте детально рассмотрим, что мы делаем в данном обработчике:

- [1] закрываем все модальные окна перед тем, как перейти на новый route
- [2] Ищем модальную компоненту. Для этого мы реализовали функцию `findModal`:

```javascript
function findModal(routerLocation) {
    for(let i = routerLocation.matched.length - 1; i >= 0; i--) {
        const components = routerLocation.matched[i].components;

        const a = Object.values(components).find(route => route._isModal);
        if (a) return a;
    }
    return null;
}
```

Если кратко объяснить, что эта функция делает: ищет обёртку, которая
была создана при помощи `useModalRouter` и возвращает её. Если углубиться
в тему, то алгоритм следующий:

1. Для текущего маршрута получаем все совпадения описанные для текущего
маршрута в routes. 
2. Получаем объект компонент, которые были указаны для рендеринга
3. ищем среди них те, у которых установлен флаг `_isModal`.

Стоп! Вряд-ли во `Vue` есть такое свойства. Всё верно, мы расширяем 
метод `useModalRouter`, теперь он выглядит так:

```js
function useModalRouter(component) {
    return {
        setup() { return null },
        _isModal: true
    }
}
```

Возвращаемся к `afterEach` хуку на позицию **[3]**. Свойства `initialize`
также нет в возвращаемом объекте, по этому также его добавляем:

```js
function useModalRouter(component) {
    return {
        initialize() {
            const params = computed(() => router.currentRoute.value.params);
            openModal(component, params);
        }
    }
}
```

Теперь, если пользователь заходит на `route` для которого должно быть
открыто модальное окно, будет происходить процесс поиска и инициализации.
Также обратите внимание на props. Здесь мы их передаём как `computed`
переменную. Для на это не проблема, т.к. в модальном контейнере Vue
самостоятельно преобразит `v-bind = "props"` к нормально виду.

## Почему пишем своё?

Для модальных окон есть несколько библиотек для работы, но они не дают
и половины функционала описанного сверху. Я просто хотел показать, что
работа с модальными окнами может быть приятной и простой. То, что я
описал выше является фундаментом для данной 
[библиотеки](https://github.com/Jenesius/vue-modal). За пару лет я 
собрал в ней функционал, который покрывает все мои потребности при
работе с модальными окнами. Добавил большое количество тестов и 
описал документацию. Возможно для кого-то она также будет полезна.
