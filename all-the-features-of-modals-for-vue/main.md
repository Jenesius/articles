Я часто вижу как в `Discrod`, на `Reddis`, да даже на `Habr`
поднимается тема модальных окон. Если зайти в официальный дискорд канал
`Vue` и включить поиск по слову _modal_, можно обнаружить, что вопросы
задаются каждый день. Хотя что может быть сложного в модальных окнах?
Создадим переменную `isOpen`, добавим `v-if` и готово. Именно это я
вижу в **90%** проектов. Но так ли удобен такой подход - определённо нет. 

Пару лет назад я решил раз и навсегда разобраться с modals. В этой 
статье будет рассказано, как разработчики применяют модальные окна, как
элегантно добавить их в свой проект. Все описанные подходы были
собраны в единую библиотеку `jenesius-vue-modal` и описаны на
[GitHub](https://github.com/Jenesius/vue-modal). 

Я поискал в официальном `Discrod` канале сообщения связанные с `modal` и
`dialog` и выделил 4 основные темы, которые поднимают разработчики:

- как открыть модальное окно
- как открыть модальное окно поверх предыдущего
- как вернуть значение из модального окна
- как прикрепить модальное окно к определённому `route`

Отлично! У нас есть требования, теперь пора их выполнить. Данная статья
будет разбита на 4 части, каждая посвящена одному из вышеописанных
пунктов. Начнём.

## Как открыть модальное окно

Мне всегда было неудобно вставлять компоненту модального окна напрямую 
в другую компоненту. Выглядит это следующим образом:

```vue
<!-- widget-user-card.vue -->
<template>
    <div class = "user">
        <!--user-card-->
        <button @click = "openUserModal"></button>
        <!--modal-->
        <modal-user :id = "userId" v-if = "isOpen"/>
    </div>
</template>
<script setup>
    const props = defineProps(['userId'])
    const isOpen = ref(false);
	
    function openUserModal() {
        isOpen.value = true;
    }
</script>
```

Если у нас приложение с одним модальным окном, то такой подход нас устроит.
Но в иных ситуациях это перегружает компоненту из-за чего их объём
начинает расти.

В `vue` третьей версии был добавлен `teleport`, для рендеринга компоненты
в другой части нашего приложения, но это ещё сильнее захламляет наш файл.
В своём проекте мы добавили новую абстракцию и передавали в неё компоненту,
которая потом `'телепортилась'` в нужное нам место.

Теперь давайте попробуем сделать это более элегантно и удобно. Как
видно из требований, нам иногда нужно отобразить несколько окон. По
этому создадим динамическую очередь, в которой будут храниться активные
модальные окна. Также опишем функцию `openModal`, которая будет использоваться
для открытия этих модальных окон:

```javascript
const modalQueue = reactive([]);

function openModal(component, props) {
    // We need close all opened modals before add new.
    modalQueue.splice(0, modalQueue.length);
    modalQueue.push({component, props})
}
```
В функцию для открытия модального окна передаётся компонента, которую
необходимо отобразить, и `props` которые будут установлены в ней. Также
не забываем, что нам нужно закрыть все ранее открытые модальные окна.

Функционал реализован, теперь создадим компоненту: контейнер в котором
данная `modalQueue` будет отображаться:

```vue
<!--modal-container.vue-->
<template>
    <component 
        v-for = "item in modalQueue"
        
        :is = "item.component"
        v-bind = "item.props"
    />
</template>
```

Я убрал описание `CSS` классов, затемнение и все остальные вторичные
детали. Здесь мы видим самое важное:
- Отображение всех компонент из modalQueue
- Передача всех `props` через `v-bind`

Также нам необходимо добавить данный контейнер в наше приложение. Я
предпочитаю добавлять его в самый конец `App.vue` компоненты, чтобы
модальные окна были всегда поверх других компонент.

Теперь обновим наш `widget-user-card` файл:

```vue
<!-- widget-user-card.vue -->
<template>
    <div class = "user">
        <!--user-card-->
        <button @click = "openUserModal"></button>
    </div>
</template>
<script setup>
    const props = defineProps(['userId'])
	
    function openUserModal() {
        openModal(ModalUser, { id: props.userId })
    }
</script>
```

Мы избавились от лишней логики в компоненте, а код стал чище.
Нам необязательно сохранять реактивность при передаче `props` в функцию,
т.к. модальное окно это новый слой логики. Но нам ничего не мешает
передать туда `computed` переменную.

## Как открыть несколько модальных окон




