*****УЧАСТНИКИ*****

*****АННОТАЦИЯ*****

*****КЛЮЧЕВЫЕ СЛОВА*****

Методы оптимизации больших информационных систем.

В данной работе будет рассмотрены причины перехода и сам переход с 
СУБД MongoDB на CasandraDB. Также будут рассмотрены требования к СУБД
для большой информационной системе на примере системы обмена 
сообщениями. 

Для ИС сперва была выбрана БД MongoDB, поскольку она являет лидирующей
СУБД для быстрого выполнения итерация. Гибкая система хранения информации,
масштабируемость, сегментирование и репликация позволяют удобно работать
с данными и обслуживать большие ИС. 

Однако большое число сообщений и данных создают следующую проблему:
данные и индексы больше не помещаются в оперативную память, 
соответственно задержки становятся непредсказуемыми. Это происходит
из-за того, что MongoDB хранит индексы в ОЗУ. В том случае, если в ОЗУ
больше нет места, СУБД будет читать индексы с диска, что повышает
время выполнения запроса.

Рассмотрим, как выглядит сегментация данных в MongoDB. Сперва выделим
основные составляющие сегментного кластера:

- **Сегмент**. Сегментный кластер распределяет данные по сегментам. 
Сегмент хранит некую часть всего множества данных.
- **Маршрутизатор mongos**. Диспетчер, которые служит для связывания
всех сегментов к единому целому. Используется для перенаправления 
операций чтения и записи на подходящий сегмент. Важно отметить, что
данные элемент системы не хранит данные.
- **Конфигурационный сервер**. Поскольку mongos не сохраняет данные, 
этим занимаются конфигурационные сервера, которые отвечают за
хранение метаданных кластера, местоположение каждой базы данных, 
информацию об изменениях и т.д.

*****ДОБАВИТЬ КАРТИНКУ КЛАСТЕРА*****

Для больших объёмов данных необходимо оптимизация СУБД. Именно в такой
ситуации прибегают к сегментации коллекции и
распределения операций чтения и записи. Каждый документ в MongoDB 
прикрепляется к диапазону посредства сегментного ключа. Сегментный
ключ состоит из комбинации одного или нескольких полей. 

Однако Для больших коллекций наступает проблема: объём данных превысил
объем ОЗУ. Постепенное добавление серверов в конечном счёте приведёт к
замедлению производительности, а задержки стали не предсказуемыми.


Опишем проблемы хранения данных в большой информационной системе 
предназначенной для обмена сообщениями:
- Невозможность определения частоты выполнения чтения и записи. Иными
словами нельзя сказать, какая операция будет выполняться чаще или реже.
- В случае групп или сообществ делающих акцент на голосовых/видео
коммуникациях, количество сообщений может не превышать 1000 за год. 
Таким образом выгрузка последних 50 сообщений повлечет к множеству 
случайных запросов на диске, вызывающих чтение данных не с ОЗУ.
- Диалоги с большим количеством участников и сообщений затрагивает
в основном именно последние сообщений. Они кешируются и находятся в
кэше диска.

Исходя из проблематики можно выделить требования к новой СУБД:
- **Линейная масштабируемость**. Отсутствие придела при котором
добавление нового сервера к кластеру не принесёт результатов.
- **Низкие затраты на обслуживание**. Простота в настройке и добавлении
новых узлов.
- **Предсказуемая производительность**. Время запросов(всех или почти
всех)не должно превышать установленный предел. Отсутствие надобности
кеширования запросов на промежуточном ПО также поможет упросить систему.
- **Открытый исходный код**. 
 
Исходя из требований описанных выше можно выделить CasandraDB. Данная
СУБД позволяет быстро и легко добавлять узлы для масштабирования. Также
она может терпеть потерю узлов без какого ли влияния на приложение.

Сделав такой выбор, необходимо доказать, что это действительно работает.

CasandraDB можно описать как KKV хранилище(Отличает от привычного 
нам Key/Value хранилища). Первичный ключ K всегда состоит из двух 
ключей: первый является ключ раздела, который показывает к какому узлу
относятся данные и где они находятся на диске. Сам раздел включает в 
себя множество строк и эта строка идентифицируется вторым ключом K и 
является ключом кластеризации. Ключ кластеризации действует как 
первичный ключ внутри раздела, а также может использоваться в качестве
элемента для сортировки строк. Например, в случае сообщений в качестве
первого ключа можно выбрать chat_id, а в качестве второго ключа
message_id. Хотя схема Casandra очень напоминает реляционную базу 
данных, их дешево изменять и они не оказывают какого-либо влияния на
производительность.

Какую проблему можно выделить, когда у нас появляются разделы 
большого объёма: большая нагрузка на CasandraDB при сжатии раздела,
невозможность кластеризации большого раздела.

Для решения данной проблемы добавим новую прослойку под названием
корзина(bucket_id) в которую будем помещать сообщения за N период
времени. В зависимости от величины проекта, величину N необходимо
подобрать самостоятельно. На текущий момент оно не должно превышать
2 гигабайте.

Теперь для получения последних сообщения в чате мы запрашиваем 
сообщения от текущего времени до времени создания чата (это ещё одна
возможность оптимизации, которая позволяет вовремя остановиться и не 
перебирать все разделы). Затем вы выбираем последовательно все разделы,
пока не будет получено нужно число сообщений или выборка будет 
завершена. Из данного утверждения можно сделать вывод, что текущее
решение будет оптимально для крупных чатов с большим количество
сообщений, поскольку их сообщения будут лежать в последних(или первом)
разделе. Однако для сообществ, где сообщения редки - данный способ наоборот
будет не эффективный, поскольку придется затратить большее время на
перебор.

https://www.linkedin.com/pulse/breathtaking-scale-75000-cassandra-nodes-10-petabytes-kumar-ashutosh/
*****ОПИСАНИЕ МАСШТАБИРУЕМОСТИ*****
*****СРАВНЕНИЕ В MONGODB*****

*****ВЫВОД*****

*****ЛИТЕРАТУРА*****


