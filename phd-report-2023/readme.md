# Обзор по теме балансировки нагрузки

Балансировка нагрузки на серверах — это процесс равномерного распределения рабочей нагрузки между несколькими серверами 
или ресурсами с целью оптимизации производительности, обеспечения стабильности работы системы и предотвращения 
перегрузок отдельных компонентов инфраструктуры.

Основная задача балансировки нагрузки — распределение запросов, трафика
или вычислительных задач между серверами таким образом, чтобы каждый из них работал в пределах своих возможностей, не 
перегружаясь, и при этом обеспечивал максимальную производительность и отказоустойчивость системы в целом.

Существует несколько основных типов балансировки нагрузки серверов, каждый из которых применяется в зависимости от 
конкретных требований и характеристик инфраструктуры. 

На данный момент существования Интернет заметна тенденция перехода от монолитной архитектуры к микросервисной. Данный
подход обусловлен большим количеством преимуществ: гибкость, масштабирование, многоязычность, развертывание и разработка.
Тем самым подход к балансировке существенно отличается от монолитной архитектуры.

В монолитном приложении весь код находится в одном приложении или в одном модуле. Это означает то, что нагрузка на сервер
является единым целым. В случае с определением нагрузки можно использовать статические методы получения текущей нагруженности
CPU, RAM и т.д.

В микросервисной архитектуре функциональность разделена на небольшие, автономные службы, что может привести к неравномерной
нагрузке. В таком случае необходимо использовать алгоритмы маршрутизации для направления запросов к конкретным узлам
приложения.

Преимущество масштабирования микросервиса заключается в том, что мы можем масштабировать не всё приложения, а отдельные
его части. В таком случае микросервис ное приложение можно представить в качестве графа, где узлы являются элементами
микросервисной архитектуры. 

Полное сравнение монолитного решения и микросервисов приведено в таблице 1.

## Единица развертывания

- Монолиты: Все компоненты приложения развертываются как единое целое. Изменения требуют перезапуска всего приложения.
- Микросервисы: Каждый микросервис может быть развернут и масштабирован независимо от других. Разворачивание и обновление происходит на уровне отдельных сервисов.

## Связность и зависимости

- Монолиты: Высокая внутренняя связность между компонентами, так как они обычно взаимодействуют напрямую.
- Микросервисы: Более низкая связность, так как микросервисы могут взаимодействовать друг с другом через API. Каждый микросервис может иметь свою собственную базу данных.

## Масштабируемость

- Монолиты: Масштабирование требует увеличения ресурсов всего приложения, даже если только один компонент испытывает высокую нагрузку.
- Микросервисы: Масштабируемость более гибкая, так как можно масштабировать только те микросервисы, которые испытывают нагрузку.

## Управление состоянием

- Монолиты: Одно общее состояние приложения, что может упростить управление данными
- Микросервисы: Каждый микросервис может иметь свое собственное состояние, что требует согласования данных между сервисами

## Отказоустойчивость

- Монолиты: Отказ любого компонента может повлиять на всю систему
- Микросервисы: Отказ одного микросервиса не обязательно приведет к отказу всей системы. Резервирование данных и использование техник, таких как контейнеризация, могут помочь обеспечить отказоустойчивость.

## Континуальная поставка (Continuous Delivery)

- Монолиты: Могут быть менее гибкими в вопросах континуальной поставки из-за необходимости развертывания всего приложения.
- Микросервисы: Позволяют легко внедрять изменения в отдельные микросервисы без прерывания работы всего приложения.

## Комплексность

- Монолиты: Обычно проще в управлении и отладке, но при достижении определенного размера и сложности становятся менее поддерживаемыми.
- Микросервисы: Могут предоставить более гибкую и масштабируемую архитектуру, но сопровождаются увеличением сложности управления сетью микросервисов.

Таким образом балансировка нагрузку в микросервисных приложениях является важной областью в исследованиях.

# Методы балансировки нагрузки

Для балансировки нагрузки существует огромное число методик, начиная с устоявшихся: RoundRobin, Weighted Load Balancing,
Stateful Load Balancing, заканчивая приближенным к экспериментальным: 

- Балансировка на основе обработки естественного языка: использует анализ естественного языка для понимания характера 
запросов и выбора подходящего сервера для обработки.

- Балансировка на основе машинного обучения: применение алгоритмов машинного обучения для анализа и прогнозирования 
нагрузки, а затем принятия решений о балансировке.

- Балансировка на основе предсказания: использует данные о предыдущих нагрузках и поведении системы для прогнозирования
будущих потребностей и балансировки нагрузки заранее.

Рассмотрим подробнее RoundRobin алгоритм, поскольку именно его используют в большинстве системах, таких как AWS, Google
Cloud. Принцип данного алгоритма заключается в том, что мы по цепочке выбираем сервер на который будет поступать запрос.
В простейшей реализации данный алгоритм не ориентируется ни на загруженность сервера, ни на сложность запроса. Из этого
вытекает основная проблема данного алгоритма: отсутствие анализа текущей ситуации. Для улучшения данного алгоритма можно
анализировать текущую нагрузку на сервер, а также сам запрос. Таким образом решаются следующие проблемы:

- анализ сервера в случае, если их производительность отличается
- анализ сложности запроса

Однако для микросервисной архитектуры можно пойти немного дальше и анализировать сам микросервис. В случае монолитного 
сервера - сервер выступает в качестве единой точкой и в таком случае производительность и нагрузка является чем-то
единым. В такой архитектуре невозможно анализировать нагруженность самого сервера. В случае с микросервисной архитектуры, 
можно применить анализ графа микросервиса для вычисления узких мест приложения.

# Исследования балансировки микросервисной архитектуры

Предположим, у вас есть микросервисы, представленные узлами графа, и зависимости между ними представлены рёбрами. Каждый
узел представляет конкретный микросервис, а рёбра - связи и зависимости между ними. Наша цель - балансировать нагрузку, 
чтобы избежать узких мест и обеспечить эффективную обработку запросов.

Пример балансировки сервера с монолитной архитектуры:
*****

Пример балансировки сервер с микросервисной архитектурой:
*****

В случае с монолитной архитектурой мы работаем с монолитом, как с единым целым. По этому балансировка выглядит достаточно
просто: отсутствует необходимость и возможность балансировать часть приложения. Именно здесь происходит неоднозначность:
мы балансируем и части приложения, где балансировка необходима, так и части для которых она является лишней.

На рисунке 2 мы сделали лишь две копии сервера, однако распределил нагрузку на сложный сервис внутри сервиса. Для решения
такой ситуации определённые части микросервиса можно помещать в отдельные контейнеры. Для них будет использоваться
отдельный балансировщик нагрузки.