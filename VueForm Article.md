## Предысторий

Больше года назад (с момента публикации статьи) я столкнулся с задачей
по реализации формы. Я не предал внимание этой задаче, и подумал, что
пару часов мне будет достаточно. Так и случилось, за пару я склепал
форму, повесил `v-model` и был доволен собой. 

Время шло, количество форм повышалось, вместе с функционалом форм. Я и
не успел моргнуть, как с обычной формой с пятью полями, я пришёл к
гигантам, которые содержали сотню полей ввода, десяток таблиц. Также
всё усугубляло то, что все эти формы являлись динамическими: в одних
условиях необходимо было показать все поля, при других часть 
заблокировать, часть скрыть. 

Вот тут я осознал: попал я по самые не хочу. Ведь что может быть хуже,
что сто `v-model`. Именно в этот самый момент я начал искать другое
решение. Я выделил следующие критерии, которым решение должно
соответствовать:

- Механизм `subscribe`. При котором дочерняя таблица сможет
подписаться на родительский элемент и обновляться в момент обновления
родителя. Достаточно простая, но полезная функция, которая
поддерживает целостность решения.
- Удобный и прозрачный механизм работы со значениями и изменениями.
Под изменениями я предполагаю механизм для отслеживания полей, которые
были изменены и либо сохранить их или откатить до первоначальных
значений.
- Возможность блокировки части формы. Как одно из решений для текущего
пункта, можно назвать динамическое построение формы. Например,
анализирую некие `metadata`, мы можем принять решение о том, стоит ли
нам показывать данное поле. Если стоит, то есть ли необходимость его
блокировать.

Выдвинув такие требования я начал шерстить интернет в поисках
элегантной библиотеки. А поскольку вы читаете данную статью - решение
не было найдено. Тогда и было решение написать что-нибудь своё и
желательно не очередной велосипед.

Теперь пару часов в день после работы я сидел и писал код. За то время
я успел выпустить две версии и речь в этой статье пойдёт именно о
второй версии. Актуальная версия находится на
[GitHub](https://github.com/Jenesius/vue-form).

## Оптимизация

В момент, когда я задумывался о том, что что-то работает (будет работать
) медленно, я пользовался тремя правилами оптимизации:

- Не оптимизируй.
- Не оптимизируй.
- Не оптимизируй.

Конечно это всё в шутку. А может и нет...

## Начало

Окей! Будем двигаться по выдвинутым выше требованиям и рассмотрим
реализацию каждого. Я постарался всё структурировать так, чтобы
читатель не видел надпись *это будет позже*.

Основной элемент (можно сказать единственный) это `Form`. На этом
этапе он из себя представляет пустой `class`. По мере рассказа я буду
расширять его.

### Subscribe

Подписка и отписка являются простыми в реализации. В класс `Form` 
добавим два свойства:

#### dependencies

- Type: `T[]`, где `T`: `T extends { name: string }`. 

Представляет собой набор дочерних элементов, которые мы подписываем на
форму. Обратите внимание, что дочерний элемент должен в себе содержать
поле `name`. В первой реализации такого условия не было, что приводило
к вопросу: кто это у нас тут подписан. Также в момент добавления в
массив в дочернем элементе в поле `parent` устанавливается ссылка на
родителя. При удалении убирается.

#### parent

- Type: `Form | null`

Та самая ссылка на родителя. Если значение `null`, то такую форму
далее в статье я буду называть **Базовой**.

Чем-то это всё напоминает модель `DOM`.

С подпиской мы закончили. На что ещё нужно обратить внимание - в
зависимости мы можем положить любую сущность: таблица, блок с 
коммуникацией, другую форму. Главное установить поле `name`. Двигаемся
дальше.

### Работа со значениями

Казалось бы нет никакой проблемы установить значение в форму и
уведомить об этом дочерний элемент. Да! Именно так было в первой
версии этого проекта. Получили значение из поля - уведомили тех, кто 
подписан на `name` из этого поля. Тут отлично вписывался `Vue` со
своей реактивностью.

Время шло, на проект был добавлен `GraphQL`. Да и логика полей
усложнилась: появились составные поля. Под составными я понимаю те, 
которые состоят из нескольких других: `Address` (страна, город, улица,
дом), `CreditCard` (номер, дата окончания обслуживания, CVV код). 
В таком случае нам удобно хранить значения полностью в разобранном
состоянии:

```json
{
  "name": "Jack",
  "address": {
    "country": "German",
    "city": "Berlin",
    "street": "Unter den Linden"
  },
  "creditCard": null
}
```

И вот мы пришли к **первому** правилу обработки: все значения
переданные в форму, должны раскладываться на простые составляющие, а
переданные названия разбиваться на составные (Я разбиваю названия по 
`.`).

В случае, если мы захотим установить следующее значение в форму:

```json
{
  "address.country": "Denmark",
  "address": {
    "city": "Copenhagen"
  }
}
```
То оно будет с конвертировано в:
```json
{
  "address": {
    "country": "Denmark",
    "city": "Copenhagen"
  }
}
```

Такой подход нам позволяет использовать поля любой сложности и 
значения любого вида и формы, т.к. они в конечном случае будут все
упрощены. 

Под простыми значениями, которые не будут раскладываться, в проекте
они называются не итерируемыми, я подразумеваю следующие:
- Примитив.
- Массив.
- Замороженный объект (`Object.isFrozen`).
- Функция.

Можно задаться вопросом, почему доходя до массива мы прерываем процесс
упрощения (развёртывания). Ответ очень прост - на это попросту не было
времени и мы не видели целесообразность. Разумеется в будущем массив
будет убран из числа *простых*. Это мой **первый** грех.

Чтобы стало ещё понятнее, для чего используется такой подход, я приведу
пример кода из своего рабочего проекта:

Компонента `address` выглядит следующим образом:
```vue
<div>
    <form-field name = "country"/>
    <form-field name = "city" />
</div>
```

Подключим её в `App.vue`:

```vue
<div>
    <form-field type = "address" name = "officeAddress"/>
    <form-field name = "officeAddress.city"/>
</div>
```

У нас отобразиться три поля. Поле `city` внутри `address` будет
связано с полем `officeAddress.city`. Иными словами они будут
полагаться на одинаковое значение в форме. Выглядит это следующим
образом:

ТУТ ДОЛЖНА БЫТЬ ГИФКА С ПРИМЕРОМ




